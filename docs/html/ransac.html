

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Ransac &mdash; Theia Vision Library</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Theia Vision Library" href="index.html"/>
        <link rel="next" title="Pose and Resectioning" href="pose.html"/>
        <link rel="prev" title="Features" href="features.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> Theia Vision Library</a>
        
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="building.html">Building Theia Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="building.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building">Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#customizing-the-build">Customizing the build</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="features.html#keypoints">Keypoints</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#keypoint-detector">Keypoint Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#descriptors">Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#descriptorextractor">DescriptorExtractor</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#feature-matching">Feature Matching</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Ransac</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#estimator"><tt class="docutils literal"><span class="pre">Estimator</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-ransac-classes">Using the RANSAC classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instances-of-ransac-methods">Instances of RANSAC Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-a-new-ransac-method">Implementing a New RANSAC Method</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pose.html">Pose and Resectioning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pose.html#perspective-three-point-p3p">Perspective Three Point (P3P)</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#five-point-relative-pose">Five Point Relative Pose</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#four-point-algorithm-for-homography">Four Point Algorithm for Homography</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#eight-point-algorithm-for-fundamental-matrix">Eight Point Algorithm for Fundamental Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#perspective-n-point">Perspective N-Point</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#four-point-focal-length">Four Point Focal Length</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#five-point-focal-length-and-radial-distortion">Five Point Focal Length and Radial Distortion</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#three-point-relative-pose-with-a-partially-known-rotation">Three Point Relative Pose with a Partially Known Rotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#four-point-relative-pose-with-a-partially-known-rotation">Four Point Relative Pose with a Partially Known Rotation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Math</a><ul>
<li class="toctree-l2"><a class="reference internal" href="math.html#closed-form-polynomial-solver">Closed Form Polynomial Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#generic-polynomial-solver">Generic Polynomial Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#guass-jordan">Guass-Jordan</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#sequential-probability-ratio-test">Sequential Probability Ratio Test</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sfm.html">Structure from Motion (SfM)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#views-and-tracks">Views and Tracks</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#twoviewinfo">TwoViewInfo</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#camera">Camera</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#reconstruction">Reconstruction</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#global-sfm-pipeline">Global SfM Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#estimating-global-poses">Estimating Global Poses</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#triangulation">Triangulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#bundle-adjustment">Bundle Adjustment</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html#similarity-transformation">Similarity Transformation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributions.html">Contributing to Theia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#style-and-testing">Style and Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#cmake">CMake</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#developing-for-theia">Developing for Theia</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#submitting-a-change-to-theia">Submitting a change to Theia</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a><ul>
<li class="toctree-l2"><a class="reference internal" href="license.html#citation">Citation</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Theia Vision Library</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Ransac</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="ransac">
<span id="documentation-ransac"></span><h1>Ransac<a class="headerlink" href="#ransac" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/RANSAC">Random Sample Consensus</a>, or RANSAC, one
of the most commonly used algorithms in Computer Vision. As a result, much
research has gone into making RANSAC extensions and variants that increase the
efficiency or accuracy of the estimation. We have implemented a templated class
that makes using RANSAC for estimation extremely easy as well as simple to
extend.</p>
<p><strong>NOTE</strong>: For the descriptions below, we often use the term &#8220;RANSAC&#8221; to mean the general strategy of model estimation via sample consensus. Most of the time, &#8220;RANSAC&#8221; refers to RANSAC and the variants we have implemented.</p>
<p>The following RANSAC methods are implemented in Theia:</p>
<ul class="simple">
<li><a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a></li>
<li><a class="reference internal" href="#Prosac" title="Prosac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Prosac</span></tt></a></li>
<li><a class="reference internal" href="#Arrsac" title="Arrsac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Arrsac</span></tt></a></li>
<li><a class="reference internal" href="#Evsac" title="Evsac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Evsac</span></tt></a></li>
</ul>
<div class="section" id="estimator">
<h2><a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a><a class="headerlink" href="#estimator" title="Permalink to this headline">¶</a></h2>
<p>The basic method for using RANSAC (and its variants) is to specify the class
corresponding to the algorithm you will use (e.g. RANSAC, PROSAC, etc.) and the
method for estimating a model from data points. The interface to do the latter
requires you implement derived class of the <a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a> class.</p>
<dl class="class">
<dt id="Estimator">
<em class="property">class </em><tt class="descname">Estimator</tt><a class="headerlink" href="#Estimator" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Datum</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Model</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Estimator</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Estimator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Estimator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">double</span> <span class="n">SampleSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">EstimateModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                             <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;*</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">double</span> <span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="n">Datum</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Functions to optionally implement.</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">EstimateModelNonminimal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;*</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">RefineModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">Model</span><span class="o">*</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ValidModel</span><span class="p">(</span><span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Helper methods implemented in base class.</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Residuals</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">GetInliers</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span>
                               <span class="kt">double</span> <span class="n">error_threshold</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">GetNumInliers</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span>
                    <span class="kt">double</span> <span class="n">error_threshold</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The only methods that are required to be implemented are the
<tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimator::EstimateModel()</span></tt>, <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimator::SampleSize()</span></tt>, and
<tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimator::Error()</span></tt> methods. These methods specify how the model is
estimated from the data provided, and how the error residuals are
calculated from a given model. All other methods are optional to
implement, but will only enhance the output of RANSAC.</p>
</dd></dl>

</div>
<div class="section" id="using-the-ransac-classes">
<h2>Using the RANSAC classes<a class="headerlink" href="#using-the-ransac-classes" title="Permalink to this headline">¶</a></h2>
<p>In order to make our RANSAC classes consistent and extendible we specify an
interface as a <tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt> class. All of the RANSAC
variants in Theia are derived from this class, so they are all guaranteed to
have the same interface. When using a RANSAC (or RANSAC-variant) class, you
simply need to create a ransac object, set up the parameters you want to use,
and then call the <a class="reference internal" href="#SampleConsensusEstimator::Estimate__std::vector:Datum:CR.ModelP.RansacSummaryP" title="SampleConsensusEstimator::Estimate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate</span></tt></a> method.</p>
<dl class="function">
<dt id="SampleConsensusEstimator::Estimate__std::vector:Datum:CR.ModelP.RansacSummaryP">
bool <tt class="descclassname">SampleConsensusEstimator::</tt><tt class="descname">Estimate</tt><big>(</big>const std::vector&lt;Datum&gt;&amp; <em>data</em>, Model* <em>best_model</em>, RansacSummary* <em>summary</em><big>)</big><a class="headerlink" href="#SampleConsensusEstimator::Estimate__std::vector:Datum:CR.ModelP.RansacSummaryP" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main (and often the only) method you use when performing RANSAC
(or a variant). It computes a model given the data and the <a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a>
class that you have specified for your problem. It returns true (and sets the
<tt class="docutils literal"><span class="pre">best_model</span></tt> parameter) upon success, and false (with <tt class="docutils literal"><span class="pre">best_model</span></tt> having
undefined behavior) upon failure.</p>
</dd></dl>

<p>The other main component of using one of the RANSAC methods is to set up the
<a class="reference internal" href="#RansacParameters" title="RansacParameters"><tt class="xref cpp cpp-class docutils literal"><span class="pre">RansacParameters</span></tt></a> used for the RANSAC scheme. <a class="reference internal" href="#RansacParameters" title="RansacParameters"><tt class="xref cpp cpp-class docutils literal"><span class="pre">RansacParameters</span></tt></a>
is a struct that holds several crucial elements to deciding how the RANSAC
scheme performs. The <a class="reference internal" href="#RansacSummary" title="RansacSummary"><tt class="xref cpp cpp-class docutils literal"><span class="pre">RansacSummary</span></tt></a> struct returns several useful
pieces of information describing the ransac run.</p>
<dl class="class">
<dt id="RansacParameters">
<em class="property">class </em><tt class="descname">RansacParameters</tt><a class="headerlink" href="#RansacParameters" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">error_thresh</span></tt>: Error threshold to determin inliers for RANSAC (e.g.,</dt>
<dd>squared reprojection error). This is what will be used by the estimator to
determine inliers.</dd>
<dt><tt class="docutils literal"><span class="pre">failure_probability</span></tt>: The failure probability of RANSAC. Set to 0.01 means</dt>
<dd>that RANSAC has a 1% chance of missing the correct pose. The default value is
0.01</dd>
<dt><tt class="docutils literal"><span class="pre">min_inlier_ratio</span></tt>: The minimal assumed inlier ratio, i.e., it is assumed</dt>
<dd>that the given set of correspondences has an inlier ratio of at least
min_inlier_ratio. This is required to limit the number of RANSAC
iteratios. The default ratio is 0.1</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">min_iterations</span></tt>: The minimum number of iterations to perform before exiting RANSAC.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">max_iterations</span></tt>: Another way to specify the maximal number of RANSAC</dt>
<dd>iterations. In effect, the maximal number of iterations is set to
min(max_ransac_iterations, T), where T is the number of iterations
corresponding to min_inlier_ratio.  This variable is useful if RANSAC is
to be applied iteratively, i.e., first applying RANSAC with an
min_inlier_ratio of x, then with one of x-y and so on, and we want to
avoid repeating RANSAC iterations.  However, the preferable way to limit
the number of RANSAC iterations is to set min_inlier_ratio and leave
max_ransac_iterations to its default value.  Per default, this variable is
set to std::numeric_limits&lt;int&gt;::max().</dd>
<dt><tt class="docutils literal"><span class="pre">use_mle</span></tt>: When set to <tt class="docutils literal"><span class="pre">true</span></tt>, the MLE score <a class="reference internal" href="bibliography.html#torr" id="id1">[Torr]</a> is used instead of</dt>
<dd>the inlier count. Thi is useful way to improve the performance of RANSAC in
most cases.</dd>
<dt><tt class="docutils literal"><span class="pre">use_Tdd_test</span></tt>: Whether to use the T_{d,d}, with d=1, test proposed in <a class="reference internal" href="bibliography.html#chumrandomizedransac" id="id2">[ChumRandomizedRansac]</a></dt>
<dd>After computing the model, RANSAC selects one match at random and evaluates all
poses. If the point is an outlier to one pose, the corresponding pose is
rejected. Notice that if the pose solver returns multiple poses, then at
most one pose is correct. If the selected match is correct, then only the
correct pose will pass the test. Per default, the test is disabled.
NOTE: Not currently implemented!</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="RansacSummary">
<em class="property">class </em><tt class="descname">RansacSummary</tt><a class="headerlink" href="#RansacSummary" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">inliers</span></tt>: A std::vector&lt;int&gt; container with inlier indices.</p>
<p><tt class="docutils literal"><span class="pre">num_iterations</span></tt>: Number of iterations required.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">confidence</span></tt>: The observed confidence of the model based on the inlier ratio</dt>
<dd>and the number of iterations performed.</dd>
</dl>
</dd></dl>

<p>We will illustrate the use of the RANSAC class with a simple line estimation example.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Our &quot;data&quot;.</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Our &quot;model&quot;.</span>
<span class="k">struct</span> <span class="n">Line</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">m</span><span class="p">;</span> <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Estimator class.</span>
<span class="k">class</span> <span class="nc">LineEstimator</span><span class="o">:</span> <span class="k">public</span> <span class="n">Estimator</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span> <span class="n">Line</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Number of points needed to estimate a line.</span>
  <span class="kt">double</span> <span class="n">SampleSize</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Estimate a line from two points.</span>
  <span class="kt">bool</span> <span class="n">EstimateModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Line</span><span class="o">&gt;*</span> <span class="n">models</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Line</span> <span class="n">model</span><span class="p">;</span>
    <span class="n">model</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">);</span>
    <span class="n">model</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">model</span><span class="p">.</span><span class="n">m</span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
    <span class="n">models</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Calculate the error as the y distance of the point to the line.</span>
  <span class="kt">double</span> <span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Line</span><span class="o">&amp;</span> <span class="n">line</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">m</span><span class="o">*</span><span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">line</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>Specifying an <a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a> is that easy! Now lets look at how to actually
use a RANSAC method to use the <tt class="xref cpp cpp-class docutils literal"><span class="pre">LineEstimator</span></tt>.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Generate your input data using your desired method.</span>
  <span class="c1">// We put pseudo-code here for simplicity.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">input_data</span><span class="p">;</span>

  <span class="c1">// Add 700 inliers.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">700</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">input_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">inlier_point</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Add 300 outliers.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">input_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">outlier_point</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Specify RANSAC parameters.</span>
  <span class="kt">double</span> <span class="n">error_threshold</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">min_num_inliers</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">max_iters</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

  <span class="c1">// Estimate the line with RANSAC.</span>
  <span class="n">LineEstimator</span> <span class="n">line_estimator</span><span class="p">;</span>
  <span class="n">Line</span> <span class="n">best_line</span><span class="p">;</span>
  <span class="c1">// Set the ransac parameters.</span>
  <span class="n">RansacParameters</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">params</span><span class="p">.</span><span class="n">error_thresh</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>

  <span class="c1">// Create Ransac object, specifying the number of points to sample to</span>
  <span class="c1">// generate a model estimation.</span>
  <span class="n">Ransac</span><span class="o">&lt;</span><span class="n">LineEstimator</span><span class="o">&gt;</span> <span class="n">ransac_estimator</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">line_estimator</span><span class="p">);</span>
  <span class="c1">// Initialize must always be called!</span>
  <span class="n">ransac_estimator</span><span class="p">.</span><span class="n">Initialize</span><span class="p">();</span>

  <span class="n">RansacSummary</span> <span class="n">summary</span><span class="p">;</span>
  <span class="n">ransac_estimator</span><span class="p">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">best_line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Line m = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">best_line</span><span class="p">.</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*x + &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">best_line</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>There you have it. With just a few lines of code we can use RANSAC to estimate
the best fitting line. You could easily swap the <a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a> class with any
of the RANSAC variants implemented in Theia without having to change anything
else in the code.</p>
</div>
<div class="section" id="instances-of-ransac-methods">
<span id="section-constructors"></span><h2>Instances of RANSAC Methods<a class="headerlink" href="#instances-of-ransac-methods" title="Permalink to this headline">¶</a></h2>
<p>Theia has implemented several RANSAC methods as derived classes of the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt> class. The typical use case is still to call
the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method, but each method is likely to have a different
constructor. The constructors for each method are specified as follows</p>
<dl class="class">
<dt id="Ransac">
<em class="property">class </em><tt class="descname">Ransac</tt><a class="headerlink" href="#Ransac" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard <a class="reference external" href="http://en.wikipedia.org/wiki/RANSAC">RANSAC</a> implementation as originally proposed by Fischler et. al. <a class="reference internal" href="bibliography.html#fischler" id="id4">[Fischler]</a></p>
<dl class="function">
<dt id="Ransac::Ransac__RansacParamsCR.EstimatorCR">
 <tt class="descname">Ransac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em><big>)</big><a class="headerlink" href="#Ransac::Ransac__RansacParamsCR.EstimatorCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="Prosac">
<em class="property">class </em><tt class="descname">Prosac</tt><a class="headerlink" href="#Prosac" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Progressive Sampling Consensus as originally proposed by <a class="reference internal" href="bibliography.html#chum" id="id5">[Chum]</a>. Input data
is assumed to have a quality to it, which can then be exposed in your
sampling strategy by smartly sampling the high quality data points first,
then progressively sampling the rest of the data set. In the worst case, this
algorithm degenerates to RANSAC, but typically is significantly faster.</div></blockquote>
<dl class="function">
<dt id="Prosac::Prosac__RansacParamsCR.EstimatorCR">
 <tt class="descname">Prosac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em><big>)</big><a class="headerlink" href="#Prosac::Prosac__RansacParamsCR.EstimatorCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="docutils">
<dt><strong>NOTE:</strong> the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method for prosace assumes the data is sorted</dt>
<dd>by quality! That is, that the highest quality data point is first, and the
worst quality data point is last in the input vector.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="Arrsac">
<em class="property">class </em><tt class="descname">Arrsac</tt><a class="headerlink" href="#Arrsac" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive Real-Time Consensus is a method proposed by <a class="reference internal" href="bibliography.html#raguram" id="id6">[Raguram]</a> that utilizes
pre-emptive techniques to perform a partially depth-first evaluation of many
generated hypotheses at once. This allows for a bounded running time while
pursuing only the models which are most likely to lead to high quality
results. This results in a very fast method which can be used for real-time applications.</p>
<dl class="function">
<dt id="Arrsac::Arrsac__RansacParamsCR.EstimatorCR.i.i">
 <tt class="descname">Arrsac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em>, int <em>max_candidate_hyps</em><em>=500</em>, int <em>block_size</em><em>=100</em><big>)</big><a class="headerlink" href="#Arrsac::Arrsac__RansacParamsCR.EstimatorCR.i.i" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">max_candidate_hyps</span></tt>: Maximum number of hypotheses in the initial hypothesis set</p>
<p><tt class="docutils literal"><span class="pre">block_size</span></tt>: Number of data points a hypothesis is evaluated against before preemptive ordering is used.</p>
</dd></dl>

<p><strong>NOTE</strong>: This method works for all the unit tests currently in
Theia, but needs to be tested further to ensure correctness. Use with
caution.</p>
</dd></dl>

<dl class="class">
<dt id="Evsac">
<em class="property">class </em><tt class="descname">Evsac</tt><a class="headerlink" href="#Evsac" title="Permalink to this definition">¶</a></dt>
<dd><p>Evsac is a method proposed by <a class="reference internal" href="bibliography.html#fragoso" id="id7">[Fragoso]</a> that models the smallest
nearest-neighbor (NN) matching distances as an inlier distribution
and an outlier distribution to compute weights for
getting a non-uniform sampling strategy. The computed non-uniform
sampling strategy tends to achieve a fast convergence, even when the
inlier ratio is small.</p>
<dl class="function">
<dt id="Evsac::Evsac__RansacParametersCR.ModelEstimatorCR.Eigen::MatrixXdCR.doubleC.FittingMethodC">
 <tt class="descname">Evsac</tt><big>(</big>const RansacParameters&amp; <em>ransac_params</em>, const ModelEstimator&amp; <em>estimator</em>, const Eigen::MatrixXd&amp; <em>sorted_distances</em>, const double <em>predictor_threshold</em>, const FittingMethod <em>fitting_method</em><big>)</big><a class="headerlink" href="#Evsac::Evsac__RansacParametersCR.ModelEstimatorCR.Eigen::MatrixXdCR.doubleC.FittingMethodC" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">ransac_params</span></tt>: The ransac parameters.</p>
<p><tt class="docutils literal"><span class="pre">estimator</span></tt>: The model estimator to use.</p>
<p><tt class="docutils literal"><span class="pre">sorted_distances</span></tt>: The matrix containing k L2 sorted
distances in ascending order. The matrix has num. of query
features as rows and k columns.</p>
<p><tt class="docutils literal"><span class="pre">predictor_threshold</span></tt>: The threshold used to decide correct or
incorrect matches/correspondences. The threshold must be in the
range of (0, 1.0). The recommended value is 0.65.</p>
<p><tt class="docutils literal"><span class="pre">fitting_method</span></tt>:  The fitting method MLE or QUANTILE_NLS.
The recommended fitting method is the MLE estimation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="implementing-a-new-ransac-method">
<h2>Implementing a New RANSAC Method<a class="headerlink" href="#implementing-a-new-ransac-method" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt> class consists of two main items: a
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and a <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt>. These two members specify
the most important aspects of most RANSAC techniques: how the data is sampled
(<tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt>) and how the model quality (or, conversely, error) is measured
(<tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt>). Adjusting the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> is how techniques
such as PROSAC achieve success. Adjusting the measurement of model quality from
the trivial method (e.g. counting inliers) is how methods such as MLESAC achieve
good results. Both the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt> classes
are pure virtual classes that must be derived for all RANSAC methods. Further,
the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method implemented in the <tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt>
base class performs a typical RANSAC style routine, sampling according to the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt> specified.</p>
<p>To implement a new RANSAC method, you should create a class derived from
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt>. Most methods will probably involve simply
using a new sampler or quality measurement class, as the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt>
function will not change and can simply be inherited from the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensus</span></tt> class. In those cases, you can follow the model of the
<a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a> class to specify your new RANSAC-variant class:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// NOTE: ModelEstimator must be a subclass of the Estimator class.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ModelEstimator</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Ransac</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SampleConsensusEstimator</span><span class="o">&lt;</span><span class="n">ModelEstimator</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ModelEstimator</span><span class="o">::</span><span class="n">Datum</span> <span class="n">Datum</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ModelEstimator</span><span class="o">::</span><span class="n">Model</span> <span class="n">Model</span><span class="p">;</span>

  <span class="k">explicit</span> <span class="nf">Ransac</span><span class="p">(</span><span class="k">const</span> <span class="n">RansacParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">,</span> <span class="k">const</span> <span class="n">ModelEstimator</span><span class="o">&amp;</span> <span class="n">estimator</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">SampleConsensusEstimator</span><span class="o">&lt;</span><span class="n">ModelEstimator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Ransac</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// Initializes the random sampler and inlier support measurement.</span>
  <span class="kt">bool</span> <span class="n">Initialize</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Sampler</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;*</span> <span class="n">random_sampler</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">RandomSampler</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">estimator_</span><span class="p">.</span><span class="n">SampleSize</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">SampleConsensusEstimator</span><span class="o">&lt;</span><span class="n">ModelEstimator</span><span class="o">&gt;::</span><span class="n">Initialize</span><span class="p">(</span>
        <span class="n">random_sampler</span><span class="p">,</span> <span class="n">inlier_support</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>This is all that the <a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a> class needs to specify, and the
<tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> function implemented in the base class
(<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt>) will use the <tt class="xref cpp cpp-class docutils literal"><span class="pre">RandomSampler</span></tt> to
randomly sample the data, and <tt class="xref cpp cpp-class docutils literal"><span class="pre">InlierSupport</span></tt> to calculate inliers. Of
course, <tt class="xref cpp cpp-class docutils literal"><span class="pre">RandomSampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">InliersSupport</span></tt> are derived classes
of <tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt> respectively. See the code
for more details.</p>
<p>If you want to create a new RANSAC method that involves changing the way
estimation happens, your class can override the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method. For our
implementation, <a class="reference internal" href="#Arrsac" title="Arrsac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Arrsac</span></tt></a> does this. See the code for those classes for a
good example on how you should override the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pose.html" class="btn btn-neutral float-right" title="Pose and Resectioning">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="features.html" class="btn btn-neutral" title="Features"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Chris Sweeney.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  MathJax.Hub.Config({
    "HTML-CSS": {
      availableFonts: ["TeX"]
    }
  });
</script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<!-- Google Analytics Code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46196711-1', 'ucsb.edu');
  ga('send', 'pageview');

</script>


</body>
</html>